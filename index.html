<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Poker Coach</title>

  <link rel="manifest" href="/manifest.webmanifest" />
  <meta name="theme-color" content="#0b0b0b" />
  <link rel="apple-touch-icon" href="/icon-192.png" />
  <link rel="stylesheet" href="style.css" />
  <script type="module" crossorigin src="/assets/index-DFygKoBP.js"></script>

  <style>
    :root{
      --card:#0b0b0b; --ink:#eee; --muted:#9aa3ad; --line:#1d1f22; --accent:#2dd4bf;
      --btn:#17191c; --btn-hi:#1f2327;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      background:#0a0a0a; color:var(--ink); line-height:1.45;
    }
    h1,h2{margin:12px 0 8px}
    .container{max-width:1100px; margin:0 auto; padding:20px}
    .card{
      background:var(--card); border:1px solid var(--line); border-radius:14px; padding:16px;
      box-shadow:0 0 0 1px rgba(255,255,255,0.02) inset;
    }
    .grid{display:grid; gap:10px}
    @media(min-width:720px){ .grid-cols{grid-template-columns:repeat(3,minmax(220px,1fr))} }
    label{font-size:.9rem; color:var(--muted); display:flex; flex-direction:column; gap:6px}
    input,select{
      background:#121417; border:1px solid var(--line); color:var(--ink);
      border-radius:10px; padding:10px 12px; outline:none;
    }
    input:focus,select:focus{border-color:#334155; box-shadow:0 0 0 3px rgba(51,65,85,.35)}
    .btnbar{display:flex; flex-wrap:wrap; gap:12px; justify-content:center}
    .btn{
      background:var(--btn); border:1px solid var(--line); color:var(--ink);
      padding:12px 26px; font-size:1.06rem; border-radius:12px; cursor:pointer;
    }
    .btn:hover{background:var(--btn-hi)}
    .muted{color:var(--muted)}
    #cameraWrap{width:100%; max-width:100%; aspect-ratio:16/9; background:#000; border:1px solid #111; border-radius:12px; overflow:hidden}
    #camera{width:100%; height:100%; object-fit:cover; object-position:center; display:block; background:#000}
    #adviceOutput{margin-top:12px; padding:14px; border:1px solid var(--line); border-radius:10px; background:#0f1114}
    .kv{display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap}
    .kv > div{min-width:180px}
  </style>
</head>

<body>
  <div class="container">
    <h1>Poker Coach</h1>

    <!-- === PRE-FLOP ADVIES === -->
    <section id="poker-advice" class="card" aria-labelledby="advice-title">
      <h2 id="advice-title">Advies voor actie</h2>
      <div class="grid grid-cols" style="margin:8px 0 12px">
        <label>Jouw hand (bv. AhKh, 9c9d, AsQs)
          <input id="adv-hand" placeholder="Bv. AhKh" autocomplete="off" />
        </label>
        <label>Jouw positie (UTG, MP, CO, BTN, SB, BB)
          <select id="adv-heroPos">
            <option>UTG</option><option>MP</option><option selected>CO</option>
            <option>BTN</option><option>SB</option><option>BB</option>
          </select>
        </label>
        <label>Aantal tegenstanders (aan tafel)
          <input id="adv-players" type="number" min="2" max="9" value="6" />
        </label>
        <label>Tegenstander type
          <select id="adv-villainType">
            <option value="normal" selected>Normal</option>
            <option value="tight">Tight</option>
            <option value="loose">Loose</option>
            <option value="aggro">Aggro</option>
            <option value="passive">Passive</option>
          </select>
        </label>
        <label>Situatie
          <select id="adv-situation">
            <option value="first-in" selected>First-in (open)</option>
            <option value="limpers">Er zijn limpers</option>
            <option value="facing-raise">Facing raise</option>
          </select>
        </label>
        <label>Aantal limpers (als van toepassing)
          <input id="adv-limpers" type="number" min="0" value="0" />
        </label>
        <label>Opener positie (als facing raise)
          <select id="adv-openerPos">
            <option>UTG</option><option>MP</option><option>CO</option>
            <option>BTN</option><option>SB</option><option>BB</option>
          </select>
        </label>
        <label>Open/raise size in bb (optioneel)
          <input id="adv-raiseSize" type="number" step="0.5" value="2.5" />
        </label>
        <label>Pot (bb, optioneel)
          <input id="adv-pot" type="number" step="0.5" value="3" />
        </label>
      </div>

      <button id="generateAdviceBtn" class="btn">üí° Bereken advies</button>
      <div id="adviceOutput" class="muted">Vul je parameters in en klik op <em>Bereken advies</em>.</div>
      <div class="muted" style="margin-top:8px"><em>Tip:</em> ranges zijn GTO-achtig en licht aangepast voor tafelgrootte &amp; tegenstandertype.</div>
    </section>

    <hr style="border:none; border-top:1px solid var(--line); margin:18px 0" />

    <!-- === SCANNER === -->
    <section id="poker-scanner" class="card" aria-labelledby="scanner-title">
      <h2 id="scanner-title">üì∑ Pokerhand Scanner</h2>

      <div id="cameraWrap" aria-label="camera">
        <video id="camera" autoplay playsinline muted></video>
      </div>
      <canvas id="scannerCanvas" style="display:none"></canvas>

      <div class="btnbar" style="margin-top:16px">
        <button id="startBtn" class="btn">‚ñ∂ Start camera</button>
        <button id="stopBtn"  class="btn">‚èπ Stop camera</button>
        <button id="calibrateBtn" class="btn">üéØ Kalibreren</button>
        <button id="resultBtn" class="btn">üÉè Scanresultaat</button>
        <button id="scanShowAdviceBtn" class="btn">üí° Toon advies</button>
      </div>

      <p id="scannerStatus" class="muted" style="margin-top:12px">Gereed‚Ä¶</p>
      <div id="scanResult" style="margin-top:10px; max-width:800px; margin-inline:auto"></div>
      <div id="scanAdvice" style="margin-top:12px; font-size:1.06rem; font-style:italic; color:#7dd3fc"></div>
    </section>
  </div>

  <script>
    // ================================
    // STATE LAYER (Stap 1)
    // ================================
    const STORAGE_KEY = 'pokerCoachStateV1';

    // --- Default state ---
    const defaultState = {
      handRaw: '',
      pos: 'CO',
      players: 6,
      villainType: 'normal',
      situation: 'first-in',
      numLimpers: 0,
      openerPos: 'UTG',
      raiseSize: 2.5,
      potSize: 3
    };
    let appState = loadState();

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? { ...defaultState, ...JSON.parse(raw) } : { ...defaultState };
      } catch {
        return { ...defaultState };
      }
    }
    function saveState() {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(appState)); } catch {}
    }

    // Koppel UI <-> state (√©√©n bron van waarheid)
    const fieldMap = {
      'adv-hand':       'handRaw',
      'adv-heroPos':    'pos',
      'adv-players':    'players',
      'adv-villainType':'villainType',
      'adv-situation':  'situation',
      'adv-limpers':    'numLimpers',
      'adv-openerPos':  'openerPos',
      'adv-raiseSize':  'raiseSize',
      'adv-pot':        'potSize'
    };

    function applyStateToUI() {
      for (const [id, key] of Object.entries(fieldMap)) {
        const el = document.getElementById(id);
        if (!el) continue;
        const v = appState[key];
        if (el.tagName === 'INPUT') el.value = v;
        else if (el.tagName === 'SELECT') el.value = v;
      }
    }
    function readUIToState() {
      for (const [id, key] of Object.entries(fieldMap)) {
        const el = document.getElementById(id);
        if (!el) continue;
        let v = el.value;
        if (['players','numLimpers','raiseSize','potSize'].includes(key)) v = Number(v);
        appState[key] = v;
      }
      saveState();
    }
    function bindInputSync() {
      for (const id of Object.keys(fieldMap)) {
        const el = document.getElementById(id);
        if (!el) continue;
        const ev = (el.tagName === 'INPUT') ? 'input' : 'change';
        el.addEventListener(ev, () => { readUIToState(); });
      }
    }

    // ================================
    // Poker helpers (ongewijzigd t.o.v. vorige versie)
    // ================================
    function canonHand(raw) {
      if (!raw) return null;
      const s = raw.replace(/[^2-9TJQKAshdc]/gi, '').toUpperCase();
      if (s.length < 4) return null;
      const r1 = s[0], s1 = s[1], r2 = s[2], s2 = s[3];
      const ranksOrder = '23456789TJQKA';
      const suited = s1 === s2;
      const [hi, lo] = (ranksOrder.indexOf(r1) >= ranksOrder.indexOf(r2)) ? [r1, r2] : [r2, r1];
      if (hi === lo) return hi + hi;
      return hi + lo + (suited ? 's' : 'o');
    }

    function expandRange(rangeStr) {
      const ranks = ['2','3','4','5','6','7','8','9','T','J','Q','K','A'];
      const idx = r => ranks.indexOf(r);
      const out = new Set();
      if (!rangeStr) return out;
      const tokens = rangeStr.replace(/\s+/g,'').split(',');
      for (let token of tokens) {
        if (!token) continue;
        if (/^Axs$/.test(token)) { for (let j=0;j<ranks.length-1;j++) out.add('A'+ranks[j]+'s'); continue; }
        if (/^Axo$/.test(token)) { for (let j=0;j<ranks.length-1;j++) out.add('A'+ranks[j]+'o'); continue; }
        if (/^([2-9TJQKA])\1\+$/.test(token)) { const start=token[0]; for (let i=idx(start); i<ranks.length; i++) out.add(ranks[i]+ranks[i]); continue; }
        if (/^([2-9TJQKA])\1-([2-9TJQKA])\2$/.test(token)) {
          const [,hi,lo]=token.match(/^([2-9TJQKA])\1-([2-9TJQKA])\2$/);
          for (let i=idx(lo); i<=idx(hi); i++) out.add(ranks[i]+ranks[i]); continue;
        }
        if (/^([2-9TJQKA])([2-9TJQKA])[so]\+$/.test(token)) {
          const [,hi,lo]=token.match(/^([2-9TJQKA])([2-9TJQKA])[so]\+$/);
          const suited = token.includes('s'); const loStart=idx(lo); const hiIdx=idx(hi);
          for (let j=loStart; j<hiIdx; j++) out.add(hi + ranks[j] + (suited?'s':'o')); continue;
        }
        if (/^([2-9TJQKA])([2-9TJQKA])[so]-([2-9TJQKA])([2-9TJQKA])[so]$/.test(token)) {
          const m=token.match(/^([2-9TJQKA])([2-9TJQKA])([so])-([2-9TJQKA])([2-9TJQKA])([so])$/);
          const hi1=m[1], lo1=m[2], s1=m[3]==='s'; const hi2=m[4], lo2=m[5], s2=m[6]==='s';
          if (hi1===hi2 && s1===s2) { const a=idx(lo2), b=idx(lo1); for (let j=a;j<=b;j++) out.add(hi1+ranks[j]+(s1?'s':'o')); }
          continue;
        }
        if (/^[2-9TJQKA][2-9TJQKA][so]$/.test(token)) { out.add(token); continue; }
        if (/^([2-9TJQKA])\1$/.test(token)) { out.add(token); continue; }
      }
      return out;
    }
    function inRange(hand, rangeStr) { return hand ? expandRange(rangeStr).has(hand) : false; }

    const OPEN_RANGES = {
      UTG: '77+,A2s+,KTs+,QTs+,JTs,T9s,98s,AQo+,KQo',
      MP:  '66+,A2s+,K9s+,QTs+,JTs,T9s,98s,87s,AQo+,KQo',
      CO:  '55+,A2s+,K8s+,Q9s+,J9s+,T8s+,97s+,AJo+,KQo',
      BTN: '44+,A2s+,K6s+,Q8s+,J8s+,T8s+,98s,87s,76s,A9o+,KTo+,QTo+,JTo',
      SB:  '66+,A2s+,K9s+,Q9s+,J9s+,T9s,98s,AQo+,KQo',
      BB:  'TT-22,Axs,KTs+,QTs+,JTs,T9s,98s,AJo+,KQo'
    };
    const ISO_RANGES = {
      EP: '77+,A2s+,KTs+,QTs+,JTs,T9s,AQo+',
      MP: '66+,A2s+,KTs+,QTs+,JTs,T9s,98s,AJo+,KQo',
      LP: '55+,A2s+,K9s+,Q9s+,J9s+,T8s+,98s,87s,AJo+,KTo+,QTo+,JTo'
    };
    const THREEBET_VS_OPEN = {
      EP: 'QQ+,AKs,AKo',
      MP: 'JJ+,AKs,AKo,AQs',
      LP: 'TT+,AKs,AKo,AQs,AQo,KQs',
      SB: 'JJ+,AKs,AKo,AQs',
      BB: 'JJ+,AKs,AKo,AQs'
    };
    const CALL_VS_OPEN = {
      EP: 'JJ-77,AQs-AJs,KQs',
      MP: 'TT-66,AQs-AJs,ATs,KQs,QJs,JTs,T9s,98s',
      LP: '99-55,AQs-ATs,AJo,KQs,KJs,QJs,JTs,T9s,98s,87s,76s',
      SB: 'TT-66,AQs-ATs,KQs,QJs,JTs,T9s,98s',
      BB: '99-22,Axs,KTs+,QTs+,JTs,T9s,98s,AJo+,KQo'
    };

    function bucket(pos) {
      if (pos==='UTG') return 'EP';
      if (pos==='MP')  return 'MP';
      if (pos==='CO' || pos==='BTN') return 'LP';
      if (pos==='SB') return 'SB';
      return 'BB';
    }
    function adjustByPlayers(rangeStr, players) {
      if (!rangeStr) return rangeStr;
      if (players <= 5) return rangeStr + ',K9s,Q9s,J9s,T8s,97s,KJo,QJo,JTo';
      if (players >= 8) return rangeStr.replace(/,KTo\+?|,QTo\+?|,JTo/g,'');
      return rangeStr;
    }
    function adjustByVillain(rangeStr, type) {
      if (!rangeStr) return rangeStr;
      const t = (type||'').toLowerCase();
      if (t==='loose' || t==='aggro') return rangeStr + ',A8o,KTo';
      if (t==='tight' || t==='passive') return rangeStr.replace(/,AJo\+?/,'');
      return rangeStr;
    }
    function openSize(pos, limpers=0, oop=false) {
      if (limpers>0) { const base=3; return (base + limpers + (oop?1:0)).toFixed(1)+'bb'; }
      if (pos==='CO' || pos==='BTN') return '2.5bb';
      return '3bb';
    }
    const threeBetSize = (ip) => (ip ? '3x open' : '4x open');

    function getPokerAdviceFull(params) {
      const {
        handRaw, pos, players, villainType, situation,
        numLimpers=0, openerPos='UTG'
      } = params;

      const hand = canonHand(handRaw);
      if (!hand) return { action:'‚Äî', reason:'Ongeldige of lege hand. Gebruik bijv. AhKh of 9c9d.' };

      if (situation==='first-in') {
        let r = OPEN_RANGES[pos] || OPEN_RANGES.UTG;
        r = adjustByPlayers(r, players);
        r = adjustByVillain(r, villainType);
        if (inRange(hand, r)) {
          const size = openSize(pos, 0, (pos==='SB'||pos==='BB'));
          return { action:`Open-raise ${size}`, reason:`${hand} valt in de ${pos}-open range.` };
        }
        return { action:'Fold', reason:`${hand} zit niet in de ${pos}-open range bij ${players}-handed.` };
      }

      if (situation==='limpers') {
        const b = bucket(pos);
        let r = ISO_RANGES[b==='LP' ? 'LP' : (b==='MP' ? 'MP' : 'EP')];
        r = adjustByPlayers(r, players);
        r = adjustByVillain(r, villainType);
        if (inRange(hand, r)) {
          const size = openSize(pos, Number(numLimpers||0), (pos==='SB'||pos==='BB'));
          return { action:`Iso-raise ${size}`, reason:`${hand} is goed als iso tegen ${numLimpers} limper(s) vanuit ${pos}.` };
        }
        const sc = '54s,65s,76s,87s,98s,T9s,JTs';
        if ((pos==='CO'||pos==='BTN') && inRange(hand, sc) && numLimpers>=2) {
          return { action:`Iso-raise ${openSize(pos, numLimpers)} of Call`, reason:`Speculatieve hand + meerdere limpers in positie.` };
        }
        return { action:'Check/Overlimp of Fold', reason:`Te marginaal om te isoleren vanuit ${pos}.` };
      }

      if (situation==='facing-raise') {
        const b = bucket(pos);
        let r3 = THREEBET_VS_OPEN[b] || THREEBET_VS_OPEN.MP;
        let rc = CALL_VS_OPEN[b]      || CALL_VS_OPEN.MP;

        r3 = adjustByPlayers(r3, players);
        rc = adjustByPlayers(rc, players);
        r3 = adjustByVillain(r3, villainType);
        rc = adjustByVillain(rc, villainType);

        const ip = (pos==='CO'||pos==='BTN') && !(openerPos==='BTN');
        if (inRange(hand, r3))  return { action:`3-bet naar ${threeBetSize(ip)}`, reason:`${hand} valt in 3-bet range (${b}) vs open uit ${openerPos}.` };
        if (inRange(hand, rc))  return { action:'Call', reason:`${hand} valt in call range (${b}) vs open uit ${openerPos}.` };
        return { action:'Fold', reason:`${hand} niet winstgevend als call/3-bet (${b}) vs ${openerPos} open.` };
      }

      return { action:'‚Äî', reason:'Onbekende situatie.' };
    }

    // ================================
    // Rendering & events (delen advies UI + scannerbutton)
    // ================================
    const adviceOutEl = document.getElementById('adviceOutput');
    function renderAdviceFromState() {
      // lees UI -> state (als iets is gewijzigd)
      readUIToState();
      const res = getPokerAdviceFull(appState);
      adviceOutEl.innerHTML = `
        <div class="kv">
          <div><strong>Actie:</strong> ${res.action}</div>
          <div><strong>Reden:</strong> ${res.reason}</div>
        </div>
      `;
      return res;
    }

    // Init UI vanuit state en live-sync
    applyStateToUI();
    bindInputSync();

    // Adviesknop (preflop sectie)
    document.getElementById('generateAdviceBtn').addEventListener('click', renderAdviceFromState);

    // ================================
    // Scanner (ongewijzigde functies + koppeling "Toon advies")
    // ================================
    (function setupScanner(){
      const video  = document.getElementById('camera');
      const canvas = document.getElementById('scannerCanvas');
      const status = document.getElementById('scannerStatus');
      const out    = document.getElementById('scanResult');
      const scanAdvice = document.getElementById('scanAdvice');

      const startB = document.getElementById('startBtn');
      const stopB  = document.getElementById('stopBtn');
      const calB   = document.getElementById('calibrateBtn');
      const resB   = document.getElementById('resultBtn');
      const showAdvB = document.getElementById('scanShowAdviceBtn');

      let stream = null;
      let calibration = loadCalibration();
      let lastScan = null;

      async function startCamera() {
        try {
          if (video.srcObject && video.srcObject.active) { status.textContent = 'Camera is al actief.'; return; }
          const constraints = {
            video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } },
            audio: false
          };
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
          status.textContent = 'Camera actief en klaar voor gebruik.';
        } catch (err) {
          status.textContent = 'Camera niet beschikbaar: ' + (err && err.message ? err.message : err);
        }
      }
      function stopCamera() {
        if (stream) {
          stream.getTracks().forEach(t => t.stop());
          video.srcObject = null;
          stream = null;
          status.textContent = 'Camera gestopt.';
        }
      }
      function videoReady() { return video && video.readyState >= 2 && (video.videoWidth||0) > 0; }

      function snapshotMetrics() {
        const w = video.videoWidth || 1280;
        const h = video.videoHeight || 720;
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(video, 0, 0, w, h);
        const { data } = ctx.getImageData(0, 0, w, h);
        let sum = 0, sumSq = 0, n = data.length / 4;
        for (let i=0; i<data.length; i+=4) {
          const y = 0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2];
          sum += y; sumSq += y*y;
        }
        const mean = sum / n;
        const variance = sumSq / n - mean*mean;
        return { mean, variance };
      }

      function calibrate() {
        if (!videoReady()) { status.textContent = 'Start eerst de camera.'; return; }
        const m = snapshotMetrics();
        calibration = { mean: m.mean, variance: m.variance, ts: Date.now() };
        saveCalibration(calibration);
        status.textContent = `Kalibratie voltooid ‚úÖ (mean=${m.mean.toFixed(1)})`;
      }

      function showResult() {
        if (!videoReady()) { status.textContent = 'Start eerst de camera.'; return; }
        const m = snapshotMetrics();
        lastScan = m;
        let compare = '<span class="muted">Geen kalibratie gevonden (tip: eerst Kalibreren).</span>';
        if (calibration) {
          const dMean = Math.abs(m.mean - calibration.mean);
          const dVar  = Math.abs(m.variance - calibration.variance);
          compare = `Œî helderheid: ${dMean.toFixed(1)}, Œî ruis: ${dVar.toFixed(1)}`;
        }
        out.innerHTML = `
          <div class="card" style="padding:12px">
            <div style="font-weight:600; margin-bottom:6px;">Scanresultaat</div>
            <div><strong>Gem. helderheid:</strong> ${m.mean.toFixed(1)}</div>
            <div><strong>Variantie (ruis):</strong> ${m.variance.toFixed(1)}</div>
            <div style="margin-top:6px;"><strong>Vergelijking t.o.v. kalibratie:</strong> ${compare}</div>
          </div>
        `;
        status.textContent = 'Scan voltooid ‚úÖ';
      }

      function showLightAdvice() {
        if (!lastScan) { scanAdvice.textContent = 'Geen scan beschikbaar. Druk eerst op ‚ÄúScanresultaat‚Äù.'; return; }
        let msg = '';
        if (lastScan.mean > 150) msg = 'Licht beeld ‚Äî probeer schaduw of afstand te corrigeren.';
        else if (lastScan.mean < 80) msg = 'Donker beeld ‚Äî zorg voor meer licht boven de tafel.';
        else msg = 'Beeldkwaliteit is goed. Analyseer nu de kaarten.';
        scanAdvice.textContent = 'Advies: ' + msg;
        status.textContent = 'Advies getoond üí°';
      }

      function saveCalibration(c) { try { localStorage.setItem('pokerScannerCalibration', JSON.stringify(c)); } catch {} }
      function loadCalibration() {
        try { const raw = localStorage.getItem('pokerScannerCalibration'); return raw ? JSON.parse(raw) : null; }
        catch { return null; }
      }

      // Events
      document.addEventListener('visibilitychange', ()=>{ if(document.hidden) stopCamera(); });
      startB.addEventListener('click', startCamera);
      stopB .addEventListener('click', stopCamera);
      calB  .addEventListener('click', calibrate);
      resB  .addEventListener('click', showResult);

      // üîó Belangrijk: "Toon advies" in de SCANNER gebruikt dezelfde appState
      showAdvB.addEventListener('click', () => {
        const res = renderAdviceFromState(); // schrijft in #adviceOutput
        // optioneel mini-echo in de scannersectie:
        scanAdvice.textContent = `Advies (kort): ${res.action}`;
        status.textContent = 'Advies (op basis van gedeelde state) bijgewerkt.';
      });

      video.addEventListener('loadeddata', () => { status.textContent = 'Camera actief.'; });
      startCamera();
    })();
  </script>
</body>
</html>
