<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Poker Coach</title>
  <meta name="theme-color" content="#0b0b0b">
  <link rel="manifest" href="/manifest.webmanifest">
  <link rel="apple-touch-icon" href="/icon-192.png">
  <style>
    :root{
      --bg:#0b0b0b; --fg:#f3f3f3; --muted:#a7a7a7; --accent:#22c55e; --warn:#f59e0b; --danger:#ef4444; 
      --card:#161616; --border:#2a2a2a;
    }
    *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Arial}
    body{margin:0;background:var(--bg);color:var(--fg)}
    h1{margin:16px 16px 8px;font-size:22px}
    .wrap{display:grid;gap:12px;padding:12px}
    .grid{display:grid;gap:12px}
    @media(min-width:900px){.grid{grid-template-columns:1.2fr .8fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px}
    .card h2{margin:0 0 8px;font-size:16px;color:var(--muted)}
    .card .inner{padding:12px}
    .video-wrap{position:relative}
    video{width:100%;height:340px;background:#000;border-radius:12px;object-fit:contain;touch-action:none}
    video.cover{object-fit:cover}
    canvas.overlay{position:absolute;left:0;top:0;width:100%;height:340px;pointer-events:none;border-radius:12px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button{
      appearance:none;border:1px solid var(--border);background:#1f1f1f;
      color:var(--fg);padding:14px 18px;border-radius:12px;font-weight:700;cursor:pointer;
      transition:transform .02s ease-in-out;font-size:16px
    }
    button:active{transform:scale(.98)}
    .btn-primary{background:var(--accent);color:#06210f;border-color:#1f7a43}
    .btn-warn{background:var(--warn);color:#231a02;border-color:#8a6506}
    .btn-danger{background:var(--danger);color:#2a0707;border-color:#9b1c1c}
    .btn-ghost{background:#1b1b1b}
    .status{font-size:13px;color:var(--muted)}
    .fields{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .fields label{font-size:12px;color:var(--muted);display:block;margin-bottom:4px}
    .fields input, .fields select{
      width:100%;padding:12px;border-radius:10px;border:1px solid var(--border);
      background:#111;color:#fff;font-size:16px
    }
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;
      background:#121212;border:1px solid var(--border);font-size:12px;color:#c9c9c9}
    .ok{color:#10b981}.maybe{color:#f59e0b}.bad{color:#ef4444}
    .mono{font-family:ui-monospace, Menlo, Consolas, monospace}
    .scanlog{white-space:pre-wrap;background:#0f0f0f;border:1px dashed #333;border-radius:10px;padding:10px;font-size:12px;color:#c9c9c9}
    .hint{font-size:12px;color:#c9c9c9;margin-left:auto}
    .zoomwrap{display:flex;align-items:center;gap:8px}
    input[type="range"]{width:140px}
  </style>
</head>
<body>
  <h1>Poker Coach</h1>

  <div class="wrap grid">
    <!-- ========================== UI: CAMERA + CONTROLS ========================== -->
    <section class="card">
      <div class="inner">
        <h2>Scanner</h2>
        <div class="video-wrap" id="videoWrap">
          <video id="camera" playsinline muted></video>
          <canvas id="overlay" class="overlay"></canvas>
        </div>

        <div class="row" style="margin-top:10px">
          <button id="btnStart" class="btn-primary">Camera aan</button>
          <button id="btnStop" class="btn-danger">Camera uit</button>
          <button id="btnCalibrate" class="btn-ghost">Kalibreer</button>
          <button id="btnResetCalib" class="btn-ghost">Reset kalibratie</button>
          <button id="btnScan" class="btn-warn">Scannen</button>
          <button id="btnAdvice" class="btn-ghost">Toon advies</button>
          <span id="status" class="status"></span>
        </div>

        <div class="row" style="margin-top:8px">
          <button id="btnRefocus" class="btn-ghost">AF opnieuw</button>
          <div class="zoomwrap">
            <button id="btnZoomOut" class="btn-ghost">–</button>
            <input id="zoomSlider" type="range" min="1" max="1" step="0.01" value="1">
            <button id="btnZoomIn" class="btn-ghost">+</button>
          </div>
          <button id="btnFitMode" class="btn-ghost">Fit: Contain</button>
          <span class="pill">Kalibratie: <strong id="calibState" class="maybe">Nodig</strong></span>
          <span class="pill">Herkenning: <strong id="recConf" class="maybe">–</strong></span>
          <span class="pill">FPS: <strong id="fps" class="">–</strong></span>
          <span class="hint" id="calibHint"></span>
        </div>
      </div>
    </section>

    <!-- ========================== UI: FIELDS + DEBUG =========================== -->
    <section class="card">
      <div class="inner">
        <h2>Gevulde velden</h2>
        <div class="fields">
          <div><label for="hand">Jouw hand</label><input id="hand" placeholder="Bijv. AhKh" autocomplete="off"></div>
          <div>
            <label for="positie">Positie</label>
            <select id="positie">
              <option value="">–</option><option>UTG</option><option>UTG+1</option><option>MP</option>
              <option>CO</option><option>BTN</option><option>SB</option><option>BB</option>
            </select>
          </div>
          <div><label for="players"># Spelers aan tafel</label><input id="players" type="number" min="2" max="10" placeholder="6"></div>
          <div><label for="callers"># Callers</label><input id="callers" type="number" min="0" max="9" placeholder="0"></div>
          <div><label for="raisers"># Raisers</label><input id="raisers" type="number" min="0" max="3" placeholder="0"></div>
          <div><label for="pot">Pot (preflop)</label><input id="pot" type="number" step="0.01" placeholder="0.00"></div>
          <div><label for="stack">Jouw stack</label><input id="stack" type="number" step="1" placeholder="100"></div>
          <div><label for="blinds">Blinds</label><input id="blinds" placeholder="1/2, 0.5/1, etc."></div>
        </div>

        <div style="margin-top:10px">
          <label>Laatste scan (debug):</label>
          <div id="scanLog" class="scanlog mono">Nog geen scan uitgevoerd.</div>
        </div>

        <!-- Crops preview -->
        <div style="margin-top:8px">
          <label>Crops preview (wat OCR ziet):</label>
          <div class="row" id="cropPreview">
            <canvas id="pvBlinds" width="240" height="80" class="card" style="background:#000;border-radius:8px"></canvas>
            <canvas id="pvPot"    width="240" height="80" class="card" style="background:#000;border-radius:8px"></canvas>
            <canvas id="pvStack"  width="240" height="80" class="card" style="background:#000;border-radius:8px"></canvas>
            <canvas id="pvHand"   width="240" height="80" class="card" style="background:#000;border-radius:8px"></canvas>
          </div>
        </div>
      </div>
    </section>
  </div>

  <!-- ========================== EXTERNAL LIBS ========================== -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <!-- ========================== SCRIPT (MODULE) ======================== -->
  <script>
/* =========================================================================
   TABLE OF CONTENTS (blokindeling)
   -------------------------------------------------------------------------
   [B1] CONFIG & STATE
   [B2] DOM HOOKS & UI HELPERS
   [B3] CAMERA LAYER (start/stop, zoom, focus, fit)
   [B4] CALIBRATIE (touch 2-tap) + OVERLAY
   [B5] OCR PIPELINE (preprocess, Tesseract, parsers, blinds fallback)
   [B6] SCAN ORCHESTRATOR (frame → crops → OCR → velden + previews)
   [B7] ADVISOR (placeholder logica)
   [B8] EVENTS (click/touch wiring)
   ========================================================================*/

/* ============================= [B1] CONFIG & STATE ===================== */
const ZONE_ORDER = ['Blinds', 'Pot', 'Stack', 'Hand'];
let stream=null, track=null, caps=null;
let rafId=null, lastFpsTime=0, frames=0;
let fitCover=false;
const frameCanvas = document.createElement('canvas');
const frameCtx = frameCanvas.getContext('2d', { willReadFrequently:true });
let calib = loadCalib();

/* ===================== [B2] DOM HOOKS & UI HELPERS ===================== */
const $ = (id) => document.getElementById(id);
const els = {
  video: $('camera'),
  overlay: $('overlay'),
  videoWrap: $('videoWrap'),
  btnStart: $('btnStart'),
  btnStop: $('btnStop'),
  btnCalibrate: $('btnCalibrate'),
  btnResetCalib: $('btnResetCalib'),
  btnScan: $('btnScan'),
  btnAdvice: $('btnAdvice'),
  btnRefocus: $('btnRefocus'),
  btnZoomOut: $('btnZoomOut'),
  btnZoomIn: $('btnZoomIn'),
  zoomSlider: $('zoomSlider'),
  btnFitMode: $('btnFitMode'),
  status: $('status'),
  calibState: $('calibState'),
  recConf: $('recConf'),
  fps: $('fps'),
  calibHint: $('calibHint'),
  hand: $('hand'),
  positie: $('positie'),
  players: $('players'),
  callers: $('callers'),
  raisers: $('raisers'),
  pot: $('pot'),
  stack: $('stack'),
  blinds: $('blinds'),
  scanLog: $('scanLog'),
  pvBlinds: $('pvBlinds'),
  pvPot: $('pvPot'),
  pvStack: $('pvStack'),
  pvHand: $('pvHand'),
};
function setStatus(msg){ els.status.textContent=msg; }
function setPill(el, txt, cls){ el.textContent=txt; el.className=cls; }
function updateCalibUI(){
  if(calib?.rects?.length===ZONE_ORDER.length){ setPill(els.calibState,'OK','ok'); }
  else { setPill(els.calibState,'Nodig','maybe'); }
}

/* ================= [B3] CAMERA LAYER (start/stop, zoom, focus, fit) ==== */
async function startCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({
      video:{
        facingMode:{ideal:'environment'}, width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:30},
        advanced:[{focusMode:'continuous'},{exposureMode:'continuous'},{whiteBalanceMode:'continuous'}]
      }, audio:false
    });
    els.video.srcObject = stream;
    await els.video.play();

    track = stream.getVideoTracks()[0];
    caps = track.getCapabilities?.() || {};

    const rect = els.video.getBoundingClientRect();
    els.overlay.width = rect.width; els.overlay.height = 340;

    initZoom();
    await tryAutoFocus();
    tickFps();
    setStatus('Camera actief.');
  }catch(err){ setStatus('Camera fout: '+err.message); }
}
function stopCamera(){
  cancelAnimationFrame(rafId);
  stream?.getTracks().forEach(t=>t.stop());
  stream=track=caps=null; els.video.srcObject=null; els.fps.textContent='–';
  setStatus('Camera uit.');
}
function tickFps(time){
  frames++; const now=time||performance.now(); if(!lastFpsTime) lastFpsTime=now;
  if(now-lastFpsTime>1000){ els.fps.textContent=String(frames); frames=0; lastFpsTime=now; }
  rafId = requestAnimationFrame(tickFps);
}
// Zoom
function initZoom(){
  if(caps?.zoom===undefined){ els.zoomSlider.disabled=els.btnZoomIn.disabled=els.btnZoomOut.disabled=true; return; }
  const min=caps.zoom.min||1, max=caps.zoom.max||1, step=caps.zoom.step||0.1;
  els.zoomSlider.min=String(min); els.zoomSlider.max=String(max); els.zoomSlider.step=String(step);
  const current = track.getSettings?.().zoom || min;
  els.zoomSlider.value=String(current);
  els.zoomSlider.oninput = ()=> setZoom(parseFloat(els.zoomSlider.value));
  els.btnZoomIn.onclick = ()=> setZoom(Math.min(max, parseFloat(els.zoomSlider.value)+step));
  els.btnZoomOut.onclick= ()=> setZoom(Math.max(min, parseFloat(els.zoomSlider.value)-step));
  // pinch
  let pinchStart=null, startZoom=current;
  els.videoWrap.addEventListener('touchstart',e=>{
    if(e.touches.length===2 && caps.zoom!==undefined){ pinchStart=dist(e.touches[0],e.touches[1]); startZoom=parseFloat(els.zoomSlider.value); }
  },{passive:true});
  els.videoWrap.addEventListener('touchmove',e=>{
    if(e.touches.length===2 && pinchStart){ const d=dist(e.touches[0],e.touches[1]); const factor=d/pinchStart;
      const target=clamp(startZoom*factor, min, max); setZoom(target); els.zoomSlider.value=String(target); }
  },{passive:true});
}
async function setZoom(z){ try{ await track?.applyConstraints({advanced:[{zoom:z}]}); }catch{} }
const dist=(a,b)=>Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
async function tryAutoFocus(){ try{
  await track?.applyConstraints({advanced:[{focusMode:'continuous'},{exposureMode:'continuous'},{whiteBalanceMode:'continuous'}]});
}catch{} }
async function refocus(){ try{
  const fm = caps?.focusMode||[];
  if(fm.includes('single-shot')){ await track?.applyConstraints({advanced:[{focusMode:'single-shot'}]}); }
  else { await track?.applyConstraints({advanced:[{focusMode:'manual'}]}); await new Promise(r=>setTimeout(r,120));
         await track?.applyConstraints({advanced:[{focusMode:'continuous'}]}); }
  setStatus('Autofocus uitgevoerd.');
}catch{ setStatus('Autofocus niet ondersteund.'); } }
function toggleFit(){
  fitCover=!fitCover;
  if(fitCover){ els.video.classList.add('cover'); els.btnFitMode.textContent='Fit: Cover'; }
  else { els.video.classList.remove('cover'); els.btnFitMode.textContent='Fit: Contain'; }
}

/* ========== [B4] CALIBRATIE (touch 2-tap) + OVERLAY TEKENING =========== */
let calibMode=false, tapStart=null, currentRects=[];
const octx = els.overlay.getContext('2d', { alpha: true }); // transparant overlay
octx.clearRect(0,0,els.overlay.width,els.overlay.height);

function beginCalib(){
  calibMode=true; tapStart=null; currentRects=[];
  els.calibHint.textContent='Tik 2× voor: '+ZONE_ORDER[currentRects.length];
  els.overlay.style.pointerEvents='auto'; drawOverlay();
  setStatus('Kalibratie: tik linkerbovenhoek en rechteronderhoek per zone.');
}
function endCalib(save=true){
  calibMode=false; tapStart=null; els.overlay.style.pointerEvents='none'; drawOverlay();
  if(save && currentRects.length===ZONE_ORDER.length){
    calib={rects:currentRects,ts:Date.now()}; saveCalib(calib);
    setPill(els.calibState,'OK','ok'); els.calibHint.textContent=''; setStatus('Kalibratie opgeslagen.');
  }else{ setStatus('Kalibratie geannuleerd of incompleet.'); }
  updateCalibUI();
}
function resetCalib(){ calib=null; currentRects=[]; tapStart=null; try{localStorage.removeItem('pc_calib_v1');}catch{}
  setPill(els.calibState,'Nodig','maybe'); els.calibHint.textContent=''; drawOverlay(); setStatus('Kalibratie gereset.');
}
function drawOverlay(){
  octx.clearRect(0,0,els.overlay.width,els.overlay.height);
  octx.save();
  octx.lineWidth=2;
  octx.strokeStyle='rgba(0,255,160,0.9)';
  octx.fillStyle='rgba(0,255,160,0.15)';
  octx.globalCompositeOperation='source-over'; // belangrijk tegen witte vlakken
  currentRects.forEach((r,i)=>{
    const p=rectPx(r);
    octx.fillRect(p.x,p.y,p.w,p.h);
    octx.strokeRect(p.x,p.y,p.w,p.h);
    octx.font='13px system-ui';
    octx.fillStyle='rgba(255,255,255,0.95)';
    octx.fillText(ZONE_ORDER[i],p.x+6,p.y+16);
    octx.fillStyle='rgba(0,255,160,0.15)';
  });
  octx.restore();
}
function rectPx(r){ const W=els.overlay.width,H=els.overlay.height; return {x:r.x*W,y:r.y*H,w:r.w*W,h:r.h*H}; }
function pointToNorm(clientX,clientY){ const rect=els.overlay.getBoundingClientRect();
  const x=(clientX-rect.left)/rect.width, y=(clientY-rect.top)/rect.height; return {x:clamp(x,0,1), y:clamp(y,0,1)}; }
// Touch & click
els.overlay.addEventListener('touchstart',(e)=>{ if(!calibMode)return; e.preventDefault();
  const t=e.changedTouches[0]; handleTap(pointToNorm(t.clientX,t.clientY)); }, {passive:false});
els.overlay.addEventListener('click',(e)=>{ if(!calibMode)return; handleTap(pointToNorm(e.clientX,e.clientY)); });
function handleTap(pt){
  if(currentRects.length>=ZONE_ORDER.length) return;
  if(!tapStart){ tapStart=pt; els.calibHint.textContent='Tik tweede hoek voor: '+ZONE_ORDER[currentRects.length]; }
  else{
    const r={x:Math.min(tapStart.x,pt.x), y:Math.min(tapStart.y,pt.y), w:Math.abs(pt.x-tapStart.x), h:Math.abs(pt.y-tapStart.y)};
    currentRects.push(r); tapStart=null; drawOverlay();
    if(currentRects.length<ZONE_ORDER.length){ els.calibHint.textContent='Tik 2× voor: '+ZONE_ORDER[currentRects.length]; }
    else { els.calibHint.textContent=''; endCalib(true); }
  }
}
function saveCalib(c){ try{ localStorage.setItem('pc_calib_v1', JSON.stringify(c)); }catch{} }
function loadCalib(){ try{ return JSON.parse(localStorage.getItem('pc_calib_v1')); }catch{ return null; } }

/* ========== [B5] OCR PIPELINE (preprocess, Tesseract, parsers, fb) ===== */
function toGrayscaleAndBoost(data){
  for(let i=0;i<data.length;i+=4){
    const r=data[i], g=data[i+1], b=data[i+2];
    let v=0.2126*r+0.7152*g+0.0722*b;      // correcte luminantie
    v=(v-128)*1.2+128;                     // contrast-boost
    v=v<0?0:v>255?255:v;
    data[i]=data[i+1]=data[i+2]=v;         // grijs
  }
}
function autoBinarize(data){
  // simpele globale threshold: gemiddelde luminantie
  let sum=0, n=0;
  for(let i=0;i<data.length;i+=4){ sum+=data[i]; n++; }
  const thr = (sum/n) || 128;
  for(let i=0;i<data.length;i+=4){
    const v = data[i] < thr ? 0 : 255;
    data[i]=data[i+1]=data[i+2]=v;
  }
}
async function ocrText(canvas, whitelist){
  try{
    const {data} = await Tesseract.recognize(canvas, 'eng', { tessedit_char_whitelist: whitelist||undefined });
    const line=(data?.text||'').trim();
    const confs=(data?.words||[]).map(w=>w.confidence||0);
    const conf=confs.length?confs.reduce((a,b)=>a+b,0)/confs.length:(data?.confidence??0);
    return { text:line, conf };
  }catch{ return { text:'', conf:0 }; }
}
function parseBlinds(t){ if(!t?.text) return '';
  const s=t.text.replace(/\s/g,''); const m=s.match(/(\$?\d+(\.\d+)?)[/](\$?\d+(\.\d+)?)/);
  return m ? `${m[1].replace('$','')}/${m[3].replace('$','')}` : '';
}
function parseNumber(t){ if(!t?.text) return NaN;
  const s=t.text.replace(/[^\d.,]/g,'').replace(',', '.'); const num=parseFloat(s);
  return Number.isFinite(num)?num:NaN;
}
function parseHand(t){ if(!t?.text) return '';
  const s=t.text.toUpperCase().replace(/\s/g,''); const m=s.match(/([2-9TJQKA])([CDHS])([2-9TJQKA])([CDHS])/);
  return m ? `${m[1]}${m[2].toLowerCase()}${m[3]}${m[4].toLowerCase()}` : '';
}
// Fallback: zoek blinds in veelvoorkomende frame-plekken
async function ocrFullFrameForBlinds(videoEl){
  const vw=videoEl.videoWidth||1280, vh=videoEl.videoHeight||720;
  const dw=640, dh=Math.round(vh*(640/vw));
  const c=document.createElement('canvas'); c.width=dw; c.height=dh;
  const ctx=c.getContext('2d',{willReadFrequently:true}); ctx.drawImage(videoEl,0,0,dw,dh);
  const candidates=[{x:0.02,y:0.02,w:0.30,h:0.12},{x:0.68,y:0.02,w:0.30,h:0.12},{x:0.35,y:0.82,w:0.30,h:0.16}];
  for(const r of candidates){
    const sx=Math.floor(r.x*dw), sy=Math.floor(r.y*dh), sw=Math.floor(r.w*dw), sh=Math.floor(r.h*dh);
    const seg=document.createElement('canvas'); seg.width=sw; seg.height=sh;
    const sctx=seg.getContext('2d',{willReadFrequently:true});
    sctx.drawImage(c,sx,sy,sw,sh,0,0,sw,sh);
    const img=sctx.getImageData(0,0,sw,sh); toGrayscaleAndBoost(img.data); autoBinarize(img.data); sctx.putImageData(img,0,0);
    const res=await ocrText(seg,'0123456789/.$ '); const cleaned=(res.text||'').replace(/\s/g,'');
    const m = cleaned.match(/(\$?\d+(\.\d+)?)[/](\$?\d+(\.\d+)?)/);
    if(m) return `${m[1].replace('$','')}/${m[3].replace('$','')}`;
  }
  return '';
}

/* ========== [B6] SCAN ORCHESTRATOR (frame → crops → OCR → velden) ====== */
function cropsFromCalib(vw,vh,rects){
  const SCALE = 2.0; // upscaling voor betere OCR
  const map={};
  rects.forEach((r,i)=>{
    const name=ZONE_ORDER[i];
    const sx=Math.floor(r.x*vw), sy=Math.floor(r.y*vh);
    const sw=Math.max(1,Math.floor(r.w*vw)), sh=Math.max(1,Math.floor(r.h*vh));

    // Output canvas op 2×
    const c=document.createElement('canvas'); c.width=Math.max(2, Math.floor(sw*SCALE)); c.height=Math.max(2, Math.floor(sh*SCALE));
    const ctx=c.getContext('2d',{willReadFrequently:true});
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(frameCanvas, sx,sy,sw,sh, 0,0,c.width,c.height);

    // Preprocess: grijs + contrast + binarize
    const img=ctx.getImageData(0,0,c.width,c.height);
    toGrayscaleAndBoost(img.data);
    autoBinarize(img.data);
    ctx.putImageData(img,0,0);

    map[name]=c;
  });
  return map;
}
function showPreviews(crops){
  const pairs = [
    [crops.Blinds, els.pvBlinds],
    [crops.Pot,    els.pvPot],
    [crops.Stack,  els.pvStack],
    [crops.Hand,   els.pvHand],
  ];
  pairs.forEach(([src, dst])=>{
    if(!src || !dst) return;
    const ctx = dst.getContext('2d', { willReadFrequently:true });
    ctx.clearRect(0,0,dst.width,dst.height);
    const scale = Math.min(dst.width/src.width, dst.height/src.height);
    const w = Math.floor(src.width*scale), h = Math.floor(src.height*scale);
    const x = Math.floor((dst.width - w)/2), y = Math.floor((dst.height - h)/2);
    ctx.drawImage(src, x, y, w, h);
  });
}
function updateConfidence(c){
  const pct = Math.round((c||0)*100); els.recConf.textContent=pct+'%';
  els.recConf.className = pct>=85?'ok':(pct>=60?'maybe':'bad');
}
function logScan(d){ els.scanLog.textContent = JSON.stringify(d,null,2); }
async function scan(){
  if(!stream){ return setStatus('Camera is niet actief.'); }
  if(!(calib?.rects?.length===ZONE_ORDER.length)){ return setStatus('Eerst kalibreren a.u.b.'); }
  setStatus('Scannen…');

  const vw=els.video.videoWidth||1280, vh=els.video.videoHeight||720;
  frameCanvas.width=vw; frameCanvas.height=vh; frameCtx.drawImage(els.video,0,0,vw,vh);

  const crops = cropsFromCalib(vw,vh,calib.rects);
  showPreviews(crops); // << previews updaten

  const out = {};

  out.blindsRaw = await ocrText(crops.Blinds,'0123456789/.$ ');
  out.blinds    = parseBlinds(out.blindsRaw);
  if(!out.blinds){ out.blinds = await ocrFullFrameForBlinds(els.video) || ''; }

  out.potRaw = await ocrText(crops.Pot,'0123456789.,$ ');
  out.pot    = parseNumber(out.potRaw);

  out.stackRaw = await ocrText(crops.Stack,'0123456789.,$ ');
  out.stack    = parseNumber(out.stackRaw);

  out.handRaw = await ocrText(crops.Hand,'23456789TJQKAcdhsCDHS ');
  out.hand    = parseHand(out.handRaw);

  const confs=[out.blindsRaw?.conf,out.potRaw?.conf,out.stackRaw?.conf,out.handRaw?.conf].filter(x=>typeof x==='number');
  const confidence = confs.length ? (confs.reduce((a,b)=>a+b,0)/confs.length)/100 : 0;

  // Mildere invul-fallbacks
  // Hand
  if(out.hand && /^[2-9TJQKA][cdhs][2-9TJQKA][cdhs]$/i.test(out.hand)){
    els.hand.value = out.hand;
  } else if(out.handRaw?.text){
    const s = out.handRaw.text.toUpperCase().replace(/\s+/g,'');
    const m = s.match(/([2-9TJQKA])[CDHS]([2-9TJQKA])[CDHS]/);
    if(m) els.hand.value = s.slice(0,4).replace(/([CDHS])/g, d=>d.toLowerCase());
  }
  // Blinds
  if(out.blinds){
    els.blinds.value = out.blinds;
  } else if(out.blindsRaw?.text){
    const cleaned = out.blindsRaw.text.replace(/\s/g,'');
    const m = cleaned.match(/(\$?\d+(?:[\.,]\d+)?)[/](\$?\d+(?:[\.,]\d+)?)/);
    if(m){ els.blinds.value = `${m[1].replace('$','').replace(',','.')}/${m[2].replace('$','').replace(',','.')}`; }
  }
  // Pot
  if(Number.isFinite(out.pot)){
    els.pot.value = out.pot;
  } else if(out.potRaw?.text){
    const m = out.potRaw.text.replace(/[^\d,\.]/g,'').replace(',','.').match(/\d+(?:\.\d+)?/);
    if(m) els.pot.value = m[0];
  }
  // Stack
  if(Number.isFinite(out.stack)){
    els.stack.value = Math.round(out.stack);
  } else if(out.stackRaw?.text){
    const m = out.stackRaw.text.replace(/[^\d,\.]/g,'').replace(',','.').match(/\d+(?:\.\d+)?/);
    if(m) els.stack.value = Math.round(parseFloat(m[0]));
  }

  logScan({blinds:out.blinds,pot:out.pot,stack:out.stack,hand:out.hand,
           raw:{blinds:out.blindsRaw?.text||null,pot:out.potRaw?.text||null,stack:out.stackRaw?.text||null,hand:out.handRaw?.text||null},
           confidence:+confidence.toFixed(2)});
  updateConfidence(confidence);
  setStatus('Scan gereed.');
}

/* ======================= [B7] ADVISOR (placeholder) ==================== */
const SimpleAdvisor = {
  advise(input){
    const deep = (()=>{ if(!input.stack||!input.blinds) return null;
      const bb=parseFloat((input.blinds.split('/')[1]||input.blinds).replace(',','.'));
      return bb? input.stack/bb : null; })();

    if(input.positie==='BTN' && input.raisers===0) return {action:'Open-raise 2.5bb',reason:'Button, geen raise voor je, brede opening.'};
    if(input.raisers>=1 && /A[KQJ]|QQ|JJ|TT/.test(input.hand)) return {action:'3-bet',reason:'Sterke hand vs eerdere raise.'};
    if(input.raisers>=1 && !/A[KQJ]|QQ|JJ|TT/.test(input.hand)) return {action:'Fold',reason:'Agressie en te zwakke hand.'};
    if(deep && deep<30 && /[KQJT]s$/i.test(input.hand)) return {action:'Shove/3-bet jam',reason:'Short stack met suited broadway.'};
    return {action:'Check/Fold',reason:'Default; verfijn met ranges.'};
  }
};

/* ============================ [B8] EVENTS ============================== */
els.btnStart.addEventListener('click', startCamera);
els.btnStop .addEventListener('click', stopCamera);
els.btnFitMode.addEventListener('click', toggleFit);
els.videoWrap.addEventListener('click', ()=>refocus());
els.btnRefocus.addEventListener('click', ()=>refocus());

els.btnCalibrate.addEventListener('click', beginCalib);
els.btnResetCalib.addEventListener('click', resetCalib);
els.btnScan.addEventListener('click', scan);
els.btnAdvice.addEventListener('click', ()=>{
  const input={
    hand:els.hand.value.trim(), positie:els.positie.value,
    players:+els.players.value||null, callers:+els.callers.value||0, raisers:+els.raisers.value||0,
    pot:+els.pot.value||0, stack:+els.stack.value||0, blinds:els.blinds.value.trim()
  };
  const adv = SimpleAdvisor.advise(input);
  alert(`Advies: ${adv.action}\n\nUitleg: ${adv.reason}`);
});

updateCalibUI();
  </script>
</body>
</html>
